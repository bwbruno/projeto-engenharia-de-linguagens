digraph Automaton {
  0 [label="0\n$accept -> . prog $end"]
  0 -> 1 [style=solid label="INT"]
  0 -> 2 [style=solid label="FLOAT"]
  0 -> 3 [style=solid label="DOUBLE"]
  0 -> 4 [style=solid label="STRING"]
  0 -> 5 [style=solid label="BOOL"]
  0 -> 6 [style=dashed label="prog"]
  0 -> 7 [style=dashed label="decls_opt"]
  0 -> 8 [style=dashed label="decls"]
  0 -> 9 [style=dashed label="decl"]
  0 -> 10 [style=dashed label="type"]
  1 [label="1\ntype -> INT ."]
  2 [label="2\ntype -> FLOAT ."]
  3 [label="3\ntype -> DOUBLE ."]
  4 [label="4\ntype -> STRING ."]
  5 [label="5\ntype -> BOOL ."]
  6 [label="6\n$accept -> prog . $end"]
  6 -> 11 [style=solid label="$end"]
  7 [label="7\nprog -> decls_opt . subprogrs"]
  7 -> 12 [style=solid label="PROCEDURE"]
  7 -> 13 [style=solid label="FUNCTION"]
  7 -> 14 [style=dashed label="subprogrs"]
  7 -> 15 [style=dashed label="subprog"]
  7 -> 16 [style=dashed label="procedure"]
  7 -> 17 [style=dashed label="function"]
  8 [label="8\ndecls_opt -> decls .\ndecls -> decls . decl"]
  8 -> 1 [style=solid label="INT"]
  8 -> 2 [style=solid label="FLOAT"]
  8 -> 3 [style=solid label="DOUBLE"]
  8 -> 4 [style=solid label="STRING"]
  8 -> 5 [style=solid label="BOOL"]
  8 -> 18 [style=dashed label="decl"]
  8 -> 10 [style=dashed label="type"]
  9 [label="9\ndecls -> decl ."]
  10 [label="10\ndecl -> type . dimen_op ids SEMI_COLON"]
  10 -> 19 [style=solid label="LBRACK"]
  10 -> 20 [style=dashed label="dimen_op"]
  11 [label="11\n$accept -> prog $end ."]
  12 [label="12\nprocedure -> PROCEDURE . ID LPAREN args_op RPAREN LBRACE stmt_list RBRACE"]
  12 -> 21 [style=solid label="ID"]
  13 [label="13\nfunction -> FUNCTION . ID LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE\nfunction -> FUNCTION . MAIN LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE"]
  13 -> 22 [style=solid label="ID"]
  13 -> 23 [style=solid label="MAIN"]
  14 [label="14\nprog -> decls_opt subprogrs .\nsubprogrs -> subprogrs . subprog"]
  14 -> 12 [style=solid label="PROCEDURE"]
  14 -> 13 [style=solid label="FUNCTION"]
  14 -> 24 [style=dashed label="subprog"]
  14 -> 16 [style=dashed label="procedure"]
  14 -> 17 [style=dashed label="function"]
  15 [label="15\nsubprogrs -> subprog ."]
  16 [label="16\nsubprog -> procedure ."]
  17 [label="17\nsubprog -> function ."]
  18 [label="18\ndecls -> decls decl ."]
  19 [label="19\ndimen_op -> LBRACK . RBRACK"]
  19 -> 25 [style=solid label="RBRACK"]
  20 [label="20\ndecl -> type dimen_op . ids SEMI_COLON\ndimen_op -> dimen_op . LBRACK RBRACK"]
  20 -> 26 [style=solid label="ID"]
  20 -> 27 [style=solid label="LBRACK"]
  20 -> 28 [style=dashed label="ids"]
  21 [label="21\nprocedure -> PROCEDURE ID . LPAREN args_op RPAREN LBRACE stmt_list RBRACE"]
  21 -> 29 [style=solid label="LPAREN"]
  22 [label="22\nfunction -> FUNCTION ID . LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE"]
  22 -> 30 [style=solid label="LPAREN"]
  23 [label="23\nfunction -> FUNCTION MAIN . LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE"]
  23 -> 31 [style=solid label="LPAREN"]
  24 [label="24\nsubprogrs -> subprogrs subprog ."]
  25 [label="25\ndimen_op -> LBRACK RBRACK ."]
  26 [label="26\nids -> ID . assign_op LBRACE expr_list RBRACE\nids -> ID . assign_op expr\nids -> ID ."]
  26 -> 32 [style=solid label="ADD_ASSIGN"]
  26 -> 33 [style=solid label="SUB_ASSIGN"]
  26 -> 34 [style=solid label="MULT_ASSIGN"]
  26 -> 35 [style=solid label="DIVIDE_ASSIGN"]
  26 -> 36 [style=solid label="MODULE_ASSIGN"]
  26 -> 37 [style=solid label="ASSIGN"]
  26 -> 38 [style=dashed label="assign_op"]
  27 [label="27\ndimen_op -> dimen_op LBRACK . RBRACK"]
  27 -> 39 [style=solid label="RBRACK"]
  28 [label="28\ndecl -> type dimen_op ids . SEMI_COLON\nids -> ids . COMMA ID assign_op expr\nids -> ids . COMMA ID"]
  28 -> 40 [style=solid label="COMMA"]
  28 -> 41 [style=solid label="SEMI_COLON"]
  29 [label="29\nprocedure -> PROCEDURE ID LPAREN . args_op RPAREN LBRACE stmt_list RBRACE"]
  29 -> 1 [style=solid label="INT"]
  29 -> 2 [style=solid label="FLOAT"]
  29 -> 3 [style=solid label="DOUBLE"]
  29 -> 4 [style=solid label="STRING"]
  29 -> 5 [style=solid label="BOOL"]
  29 -> 42 [style=dashed label="args_op"]
  29 -> 43 [style=dashed label="args"]
  29 -> 44 [style=dashed label="arg"]
  29 -> 45 [style=dashed label="type"]
  30 [label="30\nfunction -> FUNCTION ID LPAREN . args_op RPAREN COLON type LBRACE stmt_list RBRACE"]
  30 -> 1 [style=solid label="INT"]
  30 -> 2 [style=solid label="FLOAT"]
  30 -> 3 [style=solid label="DOUBLE"]
  30 -> 4 [style=solid label="STRING"]
  30 -> 5 [style=solid label="BOOL"]
  30 -> 46 [style=dashed label="args_op"]
  30 -> 43 [style=dashed label="args"]
  30 -> 44 [style=dashed label="arg"]
  30 -> 45 [style=dashed label="type"]
  31 [label="31\nfunction -> FUNCTION MAIN LPAREN . args_op RPAREN COLON type LBRACE stmt_list RBRACE"]
  31 -> 1 [style=solid label="INT"]
  31 -> 2 [style=solid label="FLOAT"]
  31 -> 3 [style=solid label="DOUBLE"]
  31 -> 4 [style=solid label="STRING"]
  31 -> 5 [style=solid label="BOOL"]
  31 -> 47 [style=dashed label="args_op"]
  31 -> 43 [style=dashed label="args"]
  31 -> 44 [style=dashed label="arg"]
  31 -> 45 [style=dashed label="type"]
  32 [label="32\nassign_op -> ADD_ASSIGN ."]
  33 [label="33\nassign_op -> SUB_ASSIGN ."]
  34 [label="34\nassign_op -> MULT_ASSIGN ."]
  35 [label="35\nassign_op -> DIVIDE_ASSIGN ."]
  36 [label="36\nassign_op -> MODULE_ASSIGN ."]
  37 [label="37\nassign_op -> ASSIGN ."]
  38 [label="38\nids -> ID assign_op . LBRACE expr_list RBRACE\nids -> ID assign_op . expr"]
  38 -> 48 [style=solid label="ID"]
  38 -> 49 [style=solid label="STRING_LITERAL"]
  38 -> 50 [style=solid label="INT_NUMBER"]
  38 -> 51 [style=solid label="DOUBLE_NUMBER"]
  38 -> 52 [style=solid label="TRUE"]
  38 -> 53 [style=solid label="FALSE"]
  38 -> 54 [style=solid label="LPAREN"]
  38 -> 55 [style=solid label="LBRACE"]
  38 -> 56 [style=dashed label="func_call"]
  38 -> 57 [style=dashed label="expr"]
  39 [label="39\ndimen_op -> dimen_op LBRACK RBRACK ."]
  40 [label="40\nids -> ids COMMA . ID assign_op expr\nids -> ids COMMA . ID"]
  40 -> 58 [style=solid label="ID"]
  41 [label="41\ndecl -> type dimen_op ids SEMI_COLON ."]
  42 [label="42\nprocedure -> PROCEDURE ID LPAREN args_op . RPAREN LBRACE stmt_list RBRACE"]
  42 -> 59 [style=solid label="RPAREN"]
  43 [label="43\nargs_op -> args .\nargs -> args . COMMA arg"]
  43 -> 60 [style=solid label="COMMA"]
  44 [label="44\nargs -> arg ."]
  45 [label="45\narg -> type . dimen_op ID"]
  45 -> 19 [style=solid label="LBRACK"]
  45 -> 61 [style=dashed label="dimen_op"]
  46 [label="46\nfunction -> FUNCTION ID LPAREN args_op . RPAREN COLON type LBRACE stmt_list RBRACE"]
  46 -> 62 [style=solid label="RPAREN"]
  47 [label="47\nfunction -> FUNCTION MAIN LPAREN args_op . RPAREN COLON type LBRACE stmt_list RBRACE"]
  47 -> 63 [style=solid label="RPAREN"]
  48 [label="48\nfunc_call -> ID . LPAREN func_args RPAREN\nexpr -> ID . dimen_ind_op"]
  48 -> 64 [style=solid label="LPAREN"]
  48 -> 65 [style=solid label="LBRACK"]
  48 -> 66 [style=dashed label="dimen_ind_op"]
  49 [label="49\nexpr -> STRING_LITERAL ."]
  50 [label="50\nexpr -> INT_NUMBER ."]
  51 [label="51\nexpr -> DOUBLE_NUMBER ."]
  52 [label="52\nexpr -> TRUE ."]
  53 [label="53\nexpr -> FALSE ."]
  54 [label="54\nexpr -> LPAREN . expr RPAREN"]
  54 -> 48 [style=solid label="ID"]
  54 -> 49 [style=solid label="STRING_LITERAL"]
  54 -> 50 [style=solid label="INT_NUMBER"]
  54 -> 51 [style=solid label="DOUBLE_NUMBER"]
  54 -> 52 [style=solid label="TRUE"]
  54 -> 53 [style=solid label="FALSE"]
  54 -> 54 [style=solid label="LPAREN"]
  54 -> 56 [style=dashed label="func_call"]
  54 -> 67 [style=dashed label="expr"]
  55 [label="55\nids -> ID assign_op LBRACE . expr_list RBRACE"]
  55 -> 48 [style=solid label="ID"]
  55 -> 49 [style=solid label="STRING_LITERAL"]
  55 -> 50 [style=solid label="INT_NUMBER"]
  55 -> 51 [style=solid label="DOUBLE_NUMBER"]
  55 -> 52 [style=solid label="TRUE"]
  55 -> 53 [style=solid label="FALSE"]
  55 -> 54 [style=solid label="LPAREN"]
  55 -> 68 [style=dashed label="expr_list"]
  55 -> 56 [style=dashed label="func_call"]
  55 -> 69 [style=dashed label="expr"]
  56 [label="56\nexpr -> func_call ."]
  57 [label="57\nids -> ID assign_op expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  57 -> 70 [style=solid label="PLUS"]
  57 -> 71 [style=solid label="MINUS"]
  57 -> 72 [style=solid label="MULT"]
  57 -> 73 [style=solid label="DIVIDE"]
  57 -> 74 [style=solid label="MODULE"]
  58 [label="58\nids -> ids COMMA ID . assign_op expr\nids -> ids COMMA ID ."]
  58 -> 32 [style=solid label="ADD_ASSIGN"]
  58 -> 33 [style=solid label="SUB_ASSIGN"]
  58 -> 34 [style=solid label="MULT_ASSIGN"]
  58 -> 35 [style=solid label="DIVIDE_ASSIGN"]
  58 -> 36 [style=solid label="MODULE_ASSIGN"]
  58 -> 37 [style=solid label="ASSIGN"]
  58 -> 75 [style=dashed label="assign_op"]
  59 [label="59\nprocedure -> PROCEDURE ID LPAREN args_op RPAREN . LBRACE stmt_list RBRACE"]
  59 -> 76 [style=solid label="LBRACE"]
  60 [label="60\nargs -> args COMMA . arg"]
  60 -> 1 [style=solid label="INT"]
  60 -> 2 [style=solid label="FLOAT"]
  60 -> 3 [style=solid label="DOUBLE"]
  60 -> 4 [style=solid label="STRING"]
  60 -> 5 [style=solid label="BOOL"]
  60 -> 77 [style=dashed label="arg"]
  60 -> 45 [style=dashed label="type"]
  61 [label="61\ndimen_op -> dimen_op . LBRACK RBRACK\narg -> type dimen_op . ID"]
  61 -> 78 [style=solid label="ID"]
  61 -> 27 [style=solid label="LBRACK"]
  62 [label="62\nfunction -> FUNCTION ID LPAREN args_op RPAREN . COLON type LBRACE stmt_list RBRACE"]
  62 -> 79 [style=solid label="COLON"]
  63 [label="63\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN . COLON type LBRACE stmt_list RBRACE"]
  63 -> 80 [style=solid label="COLON"]
  64 [label="64\nfunc_call -> ID LPAREN . func_args RPAREN"]
  64 -> 48 [style=solid label="ID"]
  64 -> 49 [style=solid label="STRING_LITERAL"]
  64 -> 50 [style=solid label="INT_NUMBER"]
  64 -> 51 [style=solid label="DOUBLE_NUMBER"]
  64 -> 52 [style=solid label="TRUE"]
  64 -> 53 [style=solid label="FALSE"]
  64 -> 54 [style=solid label="LPAREN"]
  64 -> 56 [style=dashed label="func_call"]
  64 -> 81 [style=dashed label="func_args"]
  64 -> 82 [style=dashed label="expr"]
  65 [label="65\ndimen_ind_op -> LBRACK . ind_op RBRACK dimen_ind_op"]
  65 -> 83 [style=solid label="ID"]
  65 -> 84 [style=solid label="INT_NUMBER"]
  65 -> 85 [style=solid label="LPAREN"]
  65 -> 86 [style=dashed label="ind_op"]
  65 -> 87 [style=dashed label="num_expr"]
  66 [label="66\nexpr -> ID dimen_ind_op ."]
  67 [label="67\nexpr -> LPAREN expr . RPAREN\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  67 -> 88 [style=solid label="RPAREN"]
  67 -> 70 [style=solid label="PLUS"]
  67 -> 71 [style=solid label="MINUS"]
  67 -> 72 [style=solid label="MULT"]
  67 -> 73 [style=solid label="DIVIDE"]
  67 -> 74 [style=solid label="MODULE"]
  68 [label="68\nids -> ID assign_op LBRACE expr_list . RBRACE\nexpr_list -> expr_list . COMMA expr"]
  68 -> 89 [style=solid label="COMMA"]
  68 -> 90 [style=solid label="RBRACE"]
  69 [label="69\nexpr_list -> expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  69 -> 70 [style=solid label="PLUS"]
  69 -> 71 [style=solid label="MINUS"]
  69 -> 72 [style=solid label="MULT"]
  69 -> 73 [style=solid label="DIVIDE"]
  69 -> 74 [style=solid label="MODULE"]
  70 [label="70\nexpr -> expr PLUS . expr"]
  70 -> 48 [style=solid label="ID"]
  70 -> 49 [style=solid label="STRING_LITERAL"]
  70 -> 50 [style=solid label="INT_NUMBER"]
  70 -> 51 [style=solid label="DOUBLE_NUMBER"]
  70 -> 52 [style=solid label="TRUE"]
  70 -> 53 [style=solid label="FALSE"]
  70 -> 54 [style=solid label="LPAREN"]
  70 -> 56 [style=dashed label="func_call"]
  70 -> 91 [style=dashed label="expr"]
  71 [label="71\nexpr -> expr MINUS . expr"]
  71 -> 48 [style=solid label="ID"]
  71 -> 49 [style=solid label="STRING_LITERAL"]
  71 -> 50 [style=solid label="INT_NUMBER"]
  71 -> 51 [style=solid label="DOUBLE_NUMBER"]
  71 -> 52 [style=solid label="TRUE"]
  71 -> 53 [style=solid label="FALSE"]
  71 -> 54 [style=solid label="LPAREN"]
  71 -> 56 [style=dashed label="func_call"]
  71 -> 92 [style=dashed label="expr"]
  72 [label="72\nexpr -> expr MULT . expr"]
  72 -> 48 [style=solid label="ID"]
  72 -> 49 [style=solid label="STRING_LITERAL"]
  72 -> 50 [style=solid label="INT_NUMBER"]
  72 -> 51 [style=solid label="DOUBLE_NUMBER"]
  72 -> 52 [style=solid label="TRUE"]
  72 -> 53 [style=solid label="FALSE"]
  72 -> 54 [style=solid label="LPAREN"]
  72 -> 56 [style=dashed label="func_call"]
  72 -> 93 [style=dashed label="expr"]
  73 [label="73\nexpr -> expr DIVIDE . expr"]
  73 -> 48 [style=solid label="ID"]
  73 -> 49 [style=solid label="STRING_LITERAL"]
  73 -> 50 [style=solid label="INT_NUMBER"]
  73 -> 51 [style=solid label="DOUBLE_NUMBER"]
  73 -> 52 [style=solid label="TRUE"]
  73 -> 53 [style=solid label="FALSE"]
  73 -> 54 [style=solid label="LPAREN"]
  73 -> 56 [style=dashed label="func_call"]
  73 -> 94 [style=dashed label="expr"]
  74 [label="74\nexpr -> expr MODULE . expr"]
  74 -> 48 [style=solid label="ID"]
  74 -> 49 [style=solid label="STRING_LITERAL"]
  74 -> 50 [style=solid label="INT_NUMBER"]
  74 -> 51 [style=solid label="DOUBLE_NUMBER"]
  74 -> 52 [style=solid label="TRUE"]
  74 -> 53 [style=solid label="FALSE"]
  74 -> 54 [style=solid label="LPAREN"]
  74 -> 56 [style=dashed label="func_call"]
  74 -> 95 [style=dashed label="expr"]
  75 [label="75\nids -> ids COMMA ID assign_op . expr"]
  75 -> 48 [style=solid label="ID"]
  75 -> 49 [style=solid label="STRING_LITERAL"]
  75 -> 50 [style=solid label="INT_NUMBER"]
  75 -> 51 [style=solid label="DOUBLE_NUMBER"]
  75 -> 52 [style=solid label="TRUE"]
  75 -> 53 [style=solid label="FALSE"]
  75 -> 54 [style=solid label="LPAREN"]
  75 -> 56 [style=dashed label="func_call"]
  75 -> 96 [style=dashed label="expr"]
  76 [label="76\nprocedure -> PROCEDURE ID LPAREN args_op RPAREN LBRACE . stmt_list RBRACE"]
  76 -> 97 [style=solid label="ID"]
  76 -> 1 [style=solid label="INT"]
  76 -> 2 [style=solid label="FLOAT"]
  76 -> 3 [style=solid label="DOUBLE"]
  76 -> 4 [style=solid label="STRING"]
  76 -> 5 [style=solid label="BOOL"]
  76 -> 98 [style=solid label="RETURN"]
  76 -> 99 [style=solid label="WHILE"]
  76 -> 100 [style=solid label="DO"]
  76 -> 101 [style=solid label="IF"]
  76 -> 102 [style=solid label="FOR"]
  76 -> 103 [style=solid label="SWITCH"]
  76 -> 104 [style=solid label="PRINT"]
  76 -> 105 [style=solid label="SCAN"]
  76 -> 106 [style=solid label="INCREMENT"]
  76 -> 107 [style=solid label="DECREMENT"]
  76 -> 108 [style=dashed label="decl"]
  76 -> 10 [style=dashed label="type"]
  76 -> 109 [style=dashed label="stmt_list"]
  76 -> 110 [style=dashed label="stmt"]
  76 -> 111 [style=dashed label="func_call"]
  76 -> 112 [style=dashed label="return_stmt"]
  76 -> 113 [style=dashed label="assign_stmt"]
  76 -> 114 [style=dashed label="while_stmt"]
  76 -> 115 [style=dashed label="if_stmt"]
  76 -> 116 [style=dashed label="for_stmt"]
  76 -> 117 [style=dashed label="inc_dec"]
  76 -> 118 [style=dashed label="print_stmt"]
  76 -> 119 [style=dashed label="scan_stmt"]
  76 -> 120 [style=dashed label="switch_stmt"]
  77 [label="77\nargs -> args COMMA arg ."]
  78 [label="78\narg -> type dimen_op ID ."]
  79 [label="79\nfunction -> FUNCTION ID LPAREN args_op RPAREN COLON . type LBRACE stmt_list RBRACE"]
  79 -> 1 [style=solid label="INT"]
  79 -> 2 [style=solid label="FLOAT"]
  79 -> 3 [style=solid label="DOUBLE"]
  79 -> 4 [style=solid label="STRING"]
  79 -> 5 [style=solid label="BOOL"]
  79 -> 121 [style=dashed label="type"]
  80 [label="80\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN COLON . type LBRACE stmt_list RBRACE"]
  80 -> 1 [style=solid label="INT"]
  80 -> 2 [style=solid label="FLOAT"]
  80 -> 3 [style=solid label="DOUBLE"]
  80 -> 4 [style=solid label="STRING"]
  80 -> 5 [style=solid label="BOOL"]
  80 -> 122 [style=dashed label="type"]
  81 [label="81\nfunc_call -> ID LPAREN func_args . RPAREN\nfunc_args -> func_args . COMMA expr"]
  81 -> 123 [style=solid label="COMMA"]
  81 -> 124 [style=solid label="RPAREN"]
  82 [label="82\nfunc_args -> expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  82 -> 70 [style=solid label="PLUS"]
  82 -> 71 [style=solid label="MINUS"]
  82 -> 72 [style=solid label="MULT"]
  82 -> 73 [style=solid label="DIVIDE"]
  82 -> 74 [style=solid label="MODULE"]
  83 [label="83\nnum_expr -> ID ."]
  84 [label="84\nnum_expr -> INT_NUMBER ."]
  85 [label="85\nnum_expr -> LPAREN . num_expr RPAREN"]
  85 -> 83 [style=solid label="ID"]
  85 -> 84 [style=solid label="INT_NUMBER"]
  85 -> 85 [style=solid label="LPAREN"]
  85 -> 125 [style=dashed label="num_expr"]
  86 [label="86\ndimen_ind_op -> LBRACK ind_op . RBRACK dimen_ind_op"]
  86 -> 126 [style=solid label="RBRACK"]
  87 [label="87\nind_op -> num_expr .\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr"]
  87 -> 127 [style=solid label="PLUS"]
  87 -> 128 [style=solid label="MINUS"]
  87 -> 129 [style=solid label="MULT"]
  87 -> 130 [style=solid label="DIVIDE"]
  87 -> 131 [style=solid label="MODULE"]
  88 [label="88\nexpr -> LPAREN expr RPAREN ."]
  89 [label="89\nexpr_list -> expr_list COMMA . expr"]
  89 -> 48 [style=solid label="ID"]
  89 -> 49 [style=solid label="STRING_LITERAL"]
  89 -> 50 [style=solid label="INT_NUMBER"]
  89 -> 51 [style=solid label="DOUBLE_NUMBER"]
  89 -> 52 [style=solid label="TRUE"]
  89 -> 53 [style=solid label="FALSE"]
  89 -> 54 [style=solid label="LPAREN"]
  89 -> 56 [style=dashed label="func_call"]
  89 -> 132 [style=dashed label="expr"]
  90 [label="90\nids -> ID assign_op LBRACE expr_list RBRACE ."]
  91 [label="91\nexpr -> expr . PLUS expr\nexpr -> expr PLUS expr .\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  91 -> 72 [style=solid label="MULT"]
  91 -> 73 [style=solid label="DIVIDE"]
  91 -> 74 [style=solid label="MODULE"]
  92 [label="92\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr MINUS expr .\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  92 -> 72 [style=solid label="MULT"]
  92 -> 73 [style=solid label="DIVIDE"]
  92 -> 74 [style=solid label="MODULE"]
  93 [label="93\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr MULT expr .\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  94 [label="94\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr DIVIDE expr .\nexpr -> expr . MODULE expr"]
  95 [label="95\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr\nexpr -> expr MODULE expr ."]
  96 [label="96\nids -> ids COMMA ID assign_op expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  96 -> 70 [style=solid label="PLUS"]
  96 -> 71 [style=solid label="MINUS"]
  96 -> 72 [style=solid label="MULT"]
  96 -> 73 [style=solid label="DIVIDE"]
  96 -> 74 [style=solid label="MODULE"]
  97 [label="97\nfunc_call -> ID . LPAREN func_args RPAREN\nassign_stmt -> ID . dimen_ind_op assign_op expr\ninc_dec -> ID . INCREMENT\ninc_dec -> ID . DECREMENT"]
  97 -> 64 [style=solid label="LPAREN"]
  97 -> 65 [style=solid label="LBRACK"]
  97 -> 133 [style=solid label="INCREMENT"]
  97 -> 134 [style=solid label="DECREMENT"]
  97 -> 135 [style=dashed label="dimen_ind_op"]
  98 [label="98\nreturn_stmt -> RETURN . expr SEMI_COLON"]
  98 -> 48 [style=solid label="ID"]
  98 -> 49 [style=solid label="STRING_LITERAL"]
  98 -> 50 [style=solid label="INT_NUMBER"]
  98 -> 51 [style=solid label="DOUBLE_NUMBER"]
  98 -> 52 [style=solid label="TRUE"]
  98 -> 53 [style=solid label="FALSE"]
  98 -> 54 [style=solid label="LPAREN"]
  98 -> 56 [style=dashed label="func_call"]
  98 -> 136 [style=dashed label="expr"]
  99 [label="99\nwhile_stmt -> WHILE . LPAREN condition RPAREN LBRACE stmt_list RBRACE"]
  99 -> 137 [style=solid label="LPAREN"]
  100 [label="100\nwhile_stmt -> DO . LBRACE stmt_list RBRACE WHILE LPAREN condition RPAREN SEMI_COLON"]
  100 -> 138 [style=solid label="LBRACE"]
  101 [label="101\nif_stmt -> IF . LPAREN condition RPAREN LBRACE stmt_list RBRACE else_stmt_opt"]
  101 -> 139 [style=solid label="LPAREN"]
  102 [label="102\nfor_stmt -> FOR . LPAREN for_args RPAREN LBRACE stmt_list RBRACE"]
  102 -> 140 [style=solid label="LPAREN"]
  103 [label="103\nswitch_stmt -> SWITCH . LPAREN expr RPAREN LBRACE switch_cases RBRACE"]
  103 -> 141 [style=solid label="LPAREN"]
  104 [label="104\nprint_stmt -> PRINT . LPAREN expr RPAREN"]
  104 -> 142 [style=solid label="LPAREN"]
  105 [label="105\nscan_stmt -> SCAN . LPAREN ID RPAREN"]
  105 -> 143 [style=solid label="LPAREN"]
  106 [label="106\ninc_dec -> INCREMENT . ID"]
  106 -> 144 [style=solid label="ID"]
  107 [label="107\ninc_dec -> DECREMENT . ID"]
  107 -> 145 [style=solid label="ID"]
  108 [label="108\nstmt -> decl ."]
  109 [label="109\nprocedure -> PROCEDURE ID LPAREN args_op RPAREN LBRACE stmt_list . RBRACE\nstmt_list -> stmt_list . stmt"]
  109 -> 97 [style=solid label="ID"]
  109 -> 1 [style=solid label="INT"]
  109 -> 2 [style=solid label="FLOAT"]
  109 -> 3 [style=solid label="DOUBLE"]
  109 -> 4 [style=solid label="STRING"]
  109 -> 5 [style=solid label="BOOL"]
  109 -> 98 [style=solid label="RETURN"]
  109 -> 99 [style=solid label="WHILE"]
  109 -> 100 [style=solid label="DO"]
  109 -> 101 [style=solid label="IF"]
  109 -> 102 [style=solid label="FOR"]
  109 -> 103 [style=solid label="SWITCH"]
  109 -> 104 [style=solid label="PRINT"]
  109 -> 105 [style=solid label="SCAN"]
  109 -> 146 [style=solid label="RBRACE"]
  109 -> 106 [style=solid label="INCREMENT"]
  109 -> 107 [style=solid label="DECREMENT"]
  109 -> 108 [style=dashed label="decl"]
  109 -> 10 [style=dashed label="type"]
  109 -> 147 [style=dashed label="stmt"]
  109 -> 111 [style=dashed label="func_call"]
  109 -> 112 [style=dashed label="return_stmt"]
  109 -> 113 [style=dashed label="assign_stmt"]
  109 -> 114 [style=dashed label="while_stmt"]
  109 -> 115 [style=dashed label="if_stmt"]
  109 -> 116 [style=dashed label="for_stmt"]
  109 -> 117 [style=dashed label="inc_dec"]
  109 -> 118 [style=dashed label="print_stmt"]
  109 -> 119 [style=dashed label="scan_stmt"]
  109 -> 120 [style=dashed label="switch_stmt"]
  110 [label="110\nstmt_list -> stmt ."]
  111 [label="111\nstmt -> func_call . SEMI_COLON"]
  111 -> 148 [style=solid label="SEMI_COLON"]
  112 [label="112\nstmt -> return_stmt ."]
  113 [label="113\nstmt -> assign_stmt . SEMI_COLON"]
  113 -> 149 [style=solid label="SEMI_COLON"]
  114 [label="114\nstmt -> while_stmt ."]
  115 [label="115\nstmt -> if_stmt ."]
  116 [label="116\nstmt -> for_stmt ."]
  117 [label="117\nstmt -> inc_dec . SEMI_COLON"]
  117 -> 150 [style=solid label="SEMI_COLON"]
  118 [label="118\nstmt -> print_stmt . SEMI_COLON"]
  118 -> 151 [style=solid label="SEMI_COLON"]
  119 [label="119\nstmt -> scan_stmt . SEMI_COLON"]
  119 -> 152 [style=solid label="SEMI_COLON"]
  120 [label="120\nstmt -> switch_stmt ."]
  121 [label="121\nfunction -> FUNCTION ID LPAREN args_op RPAREN COLON type . LBRACE stmt_list RBRACE"]
  121 -> 153 [style=solid label="LBRACE"]
  122 [label="122\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN COLON type . LBRACE stmt_list RBRACE"]
  122 -> 154 [style=solid label="LBRACE"]
  123 [label="123\nfunc_args -> func_args COMMA . expr"]
  123 -> 48 [style=solid label="ID"]
  123 -> 49 [style=solid label="STRING_LITERAL"]
  123 -> 50 [style=solid label="INT_NUMBER"]
  123 -> 51 [style=solid label="DOUBLE_NUMBER"]
  123 -> 52 [style=solid label="TRUE"]
  123 -> 53 [style=solid label="FALSE"]
  123 -> 54 [style=solid label="LPAREN"]
  123 -> 56 [style=dashed label="func_call"]
  123 -> 155 [style=dashed label="expr"]
  124 [label="124\nfunc_call -> ID LPAREN func_args RPAREN ."]
  125 [label="125\nnum_expr -> LPAREN num_expr . RPAREN\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr"]
  125 -> 156 [style=solid label="RPAREN"]
  125 -> 127 [style=solid label="PLUS"]
  125 -> 128 [style=solid label="MINUS"]
  125 -> 129 [style=solid label="MULT"]
  125 -> 130 [style=solid label="DIVIDE"]
  125 -> 131 [style=solid label="MODULE"]
  126 [label="126\ndimen_ind_op -> LBRACK ind_op RBRACK . dimen_ind_op"]
  126 -> 65 [style=solid label="LBRACK"]
  126 -> 157 [style=dashed label="dimen_ind_op"]
  127 [label="127\nnum_expr -> num_expr PLUS . num_expr"]
  127 -> 83 [style=solid label="ID"]
  127 -> 84 [style=solid label="INT_NUMBER"]
  127 -> 85 [style=solid label="LPAREN"]
  127 -> 158 [style=dashed label="num_expr"]
  128 [label="128\nnum_expr -> num_expr MINUS . num_expr"]
  128 -> 83 [style=solid label="ID"]
  128 -> 84 [style=solid label="INT_NUMBER"]
  128 -> 85 [style=solid label="LPAREN"]
  128 -> 159 [style=dashed label="num_expr"]
  129 [label="129\nnum_expr -> num_expr MULT . num_expr"]
  129 -> 83 [style=solid label="ID"]
  129 -> 84 [style=solid label="INT_NUMBER"]
  129 -> 85 [style=solid label="LPAREN"]
  129 -> 160 [style=dashed label="num_expr"]
  130 [label="130\nnum_expr -> num_expr DIVIDE . num_expr"]
  130 -> 83 [style=solid label="ID"]
  130 -> 84 [style=solid label="INT_NUMBER"]
  130 -> 85 [style=solid label="LPAREN"]
  130 -> 161 [style=dashed label="num_expr"]
  131 [label="131\nnum_expr -> num_expr MODULE . num_expr"]
  131 -> 83 [style=solid label="ID"]
  131 -> 84 [style=solid label="INT_NUMBER"]
  131 -> 85 [style=solid label="LPAREN"]
  131 -> 162 [style=dashed label="num_expr"]
  132 [label="132\nexpr_list -> expr_list COMMA expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  132 -> 70 [style=solid label="PLUS"]
  132 -> 71 [style=solid label="MINUS"]
  132 -> 72 [style=solid label="MULT"]
  132 -> 73 [style=solid label="DIVIDE"]
  132 -> 74 [style=solid label="MODULE"]
  133 [label="133\ninc_dec -> ID INCREMENT ."]
  134 [label="134\ninc_dec -> ID DECREMENT ."]
  135 [label="135\nassign_stmt -> ID dimen_ind_op . assign_op expr"]
  135 -> 32 [style=solid label="ADD_ASSIGN"]
  135 -> 33 [style=solid label="SUB_ASSIGN"]
  135 -> 34 [style=solid label="MULT_ASSIGN"]
  135 -> 35 [style=solid label="DIVIDE_ASSIGN"]
  135 -> 36 [style=solid label="MODULE_ASSIGN"]
  135 -> 37 [style=solid label="ASSIGN"]
  135 -> 163 [style=dashed label="assign_op"]
  136 [label="136\nreturn_stmt -> RETURN expr . SEMI_COLON\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  136 -> 164 [style=solid label="SEMI_COLON"]
  136 -> 70 [style=solid label="PLUS"]
  136 -> 71 [style=solid label="MINUS"]
  136 -> 72 [style=solid label="MULT"]
  136 -> 73 [style=solid label="DIVIDE"]
  136 -> 74 [style=solid label="MODULE"]
  137 [label="137\nwhile_stmt -> WHILE LPAREN . condition RPAREN LBRACE stmt_list RBRACE"]
  137 -> 165 [style=solid label="ID"]
  137 -> 49 [style=solid label="STRING_LITERAL"]
  137 -> 50 [style=solid label="INT_NUMBER"]
  137 -> 51 [style=solid label="DOUBLE_NUMBER"]
  137 -> 166 [style=solid label="TRUE"]
  137 -> 167 [style=solid label="FALSE"]
  137 -> 54 [style=solid label="LPAREN"]
  137 -> 56 [style=dashed label="func_call"]
  137 -> 168 [style=dashed label="expr"]
  137 -> 169 [style=dashed label="condition"]
  137 -> 170 [style=dashed label="c_term"]
  137 -> 171 [style=dashed label="comp"]
  137 -> 172 [style=dashed label="comp_term"]
  138 [label="138\nwhile_stmt -> DO LBRACE . stmt_list RBRACE WHILE LPAREN condition RPAREN SEMI_COLON"]
  138 -> 97 [style=solid label="ID"]
  138 -> 1 [style=solid label="INT"]
  138 -> 2 [style=solid label="FLOAT"]
  138 -> 3 [style=solid label="DOUBLE"]
  138 -> 4 [style=solid label="STRING"]
  138 -> 5 [style=solid label="BOOL"]
  138 -> 98 [style=solid label="RETURN"]
  138 -> 99 [style=solid label="WHILE"]
  138 -> 100 [style=solid label="DO"]
  138 -> 101 [style=solid label="IF"]
  138 -> 102 [style=solid label="FOR"]
  138 -> 103 [style=solid label="SWITCH"]
  138 -> 104 [style=solid label="PRINT"]
  138 -> 105 [style=solid label="SCAN"]
  138 -> 106 [style=solid label="INCREMENT"]
  138 -> 107 [style=solid label="DECREMENT"]
  138 -> 108 [style=dashed label="decl"]
  138 -> 10 [style=dashed label="type"]
  138 -> 173 [style=dashed label="stmt_list"]
  138 -> 110 [style=dashed label="stmt"]
  138 -> 111 [style=dashed label="func_call"]
  138 -> 112 [style=dashed label="return_stmt"]
  138 -> 113 [style=dashed label="assign_stmt"]
  138 -> 114 [style=dashed label="while_stmt"]
  138 -> 115 [style=dashed label="if_stmt"]
  138 -> 116 [style=dashed label="for_stmt"]
  138 -> 117 [style=dashed label="inc_dec"]
  138 -> 118 [style=dashed label="print_stmt"]
  138 -> 119 [style=dashed label="scan_stmt"]
  138 -> 120 [style=dashed label="switch_stmt"]
  139 [label="139\nif_stmt -> IF LPAREN . condition RPAREN LBRACE stmt_list RBRACE else_stmt_opt"]
  139 -> 165 [style=solid label="ID"]
  139 -> 49 [style=solid label="STRING_LITERAL"]
  139 -> 50 [style=solid label="INT_NUMBER"]
  139 -> 51 [style=solid label="DOUBLE_NUMBER"]
  139 -> 166 [style=solid label="TRUE"]
  139 -> 167 [style=solid label="FALSE"]
  139 -> 54 [style=solid label="LPAREN"]
  139 -> 56 [style=dashed label="func_call"]
  139 -> 168 [style=dashed label="expr"]
  139 -> 174 [style=dashed label="condition"]
  139 -> 170 [style=dashed label="c_term"]
  139 -> 171 [style=dashed label="comp"]
  139 -> 172 [style=dashed label="comp_term"]
  140 [label="140\nfor_stmt -> FOR LPAREN . for_args RPAREN LBRACE stmt_list RBRACE"]
  140 -> 175 [style=solid label="ID"]
  140 -> 176 [style=dashed label="assign_stmt"]
  140 -> 177 [style=dashed label="for_args"]
  141 [label="141\nswitch_stmt -> SWITCH LPAREN . expr RPAREN LBRACE switch_cases RBRACE"]
  141 -> 48 [style=solid label="ID"]
  141 -> 49 [style=solid label="STRING_LITERAL"]
  141 -> 50 [style=solid label="INT_NUMBER"]
  141 -> 51 [style=solid label="DOUBLE_NUMBER"]
  141 -> 52 [style=solid label="TRUE"]
  141 -> 53 [style=solid label="FALSE"]
  141 -> 54 [style=solid label="LPAREN"]
  141 -> 56 [style=dashed label="func_call"]
  141 -> 178 [style=dashed label="expr"]
  142 [label="142\nprint_stmt -> PRINT LPAREN . expr RPAREN"]
  142 -> 48 [style=solid label="ID"]
  142 -> 49 [style=solid label="STRING_LITERAL"]
  142 -> 50 [style=solid label="INT_NUMBER"]
  142 -> 51 [style=solid label="DOUBLE_NUMBER"]
  142 -> 52 [style=solid label="TRUE"]
  142 -> 53 [style=solid label="FALSE"]
  142 -> 54 [style=solid label="LPAREN"]
  142 -> 56 [style=dashed label="func_call"]
  142 -> 179 [style=dashed label="expr"]
  143 [label="143\nscan_stmt -> SCAN LPAREN . ID RPAREN"]
  143 -> 180 [style=solid label="ID"]
  144 [label="144\ninc_dec -> INCREMENT ID ."]
  145 [label="145\ninc_dec -> DECREMENT ID ."]
  146 [label="146\nprocedure -> PROCEDURE ID LPAREN args_op RPAREN LBRACE stmt_list RBRACE ."]
  147 [label="147\nstmt_list -> stmt_list stmt ."]
  148 [label="148\nstmt -> func_call SEMI_COLON ."]
  149 [label="149\nstmt -> assign_stmt SEMI_COLON ."]
  150 [label="150\nstmt -> inc_dec SEMI_COLON ."]
  151 [label="151\nstmt -> print_stmt SEMI_COLON ."]
  152 [label="152\nstmt -> scan_stmt SEMI_COLON ."]
  153 [label="153\nfunction -> FUNCTION ID LPAREN args_op RPAREN COLON type LBRACE . stmt_list RBRACE"]
  153 -> 97 [style=solid label="ID"]
  153 -> 1 [style=solid label="INT"]
  153 -> 2 [style=solid label="FLOAT"]
  153 -> 3 [style=solid label="DOUBLE"]
  153 -> 4 [style=solid label="STRING"]
  153 -> 5 [style=solid label="BOOL"]
  153 -> 98 [style=solid label="RETURN"]
  153 -> 99 [style=solid label="WHILE"]
  153 -> 100 [style=solid label="DO"]
  153 -> 101 [style=solid label="IF"]
  153 -> 102 [style=solid label="FOR"]
  153 -> 103 [style=solid label="SWITCH"]
  153 -> 104 [style=solid label="PRINT"]
  153 -> 105 [style=solid label="SCAN"]
  153 -> 106 [style=solid label="INCREMENT"]
  153 -> 107 [style=solid label="DECREMENT"]
  153 -> 108 [style=dashed label="decl"]
  153 -> 10 [style=dashed label="type"]
  153 -> 181 [style=dashed label="stmt_list"]
  153 -> 110 [style=dashed label="stmt"]
  153 -> 111 [style=dashed label="func_call"]
  153 -> 112 [style=dashed label="return_stmt"]
  153 -> 113 [style=dashed label="assign_stmt"]
  153 -> 114 [style=dashed label="while_stmt"]
  153 -> 115 [style=dashed label="if_stmt"]
  153 -> 116 [style=dashed label="for_stmt"]
  153 -> 117 [style=dashed label="inc_dec"]
  153 -> 118 [style=dashed label="print_stmt"]
  153 -> 119 [style=dashed label="scan_stmt"]
  153 -> 120 [style=dashed label="switch_stmt"]
  154 [label="154\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN COLON type LBRACE . stmt_list RBRACE"]
  154 -> 97 [style=solid label="ID"]
  154 -> 1 [style=solid label="INT"]
  154 -> 2 [style=solid label="FLOAT"]
  154 -> 3 [style=solid label="DOUBLE"]
  154 -> 4 [style=solid label="STRING"]
  154 -> 5 [style=solid label="BOOL"]
  154 -> 98 [style=solid label="RETURN"]
  154 -> 99 [style=solid label="WHILE"]
  154 -> 100 [style=solid label="DO"]
  154 -> 101 [style=solid label="IF"]
  154 -> 102 [style=solid label="FOR"]
  154 -> 103 [style=solid label="SWITCH"]
  154 -> 104 [style=solid label="PRINT"]
  154 -> 105 [style=solid label="SCAN"]
  154 -> 106 [style=solid label="INCREMENT"]
  154 -> 107 [style=solid label="DECREMENT"]
  154 -> 108 [style=dashed label="decl"]
  154 -> 10 [style=dashed label="type"]
  154 -> 182 [style=dashed label="stmt_list"]
  154 -> 110 [style=dashed label="stmt"]
  154 -> 111 [style=dashed label="func_call"]
  154 -> 112 [style=dashed label="return_stmt"]
  154 -> 113 [style=dashed label="assign_stmt"]
  154 -> 114 [style=dashed label="while_stmt"]
  154 -> 115 [style=dashed label="if_stmt"]
  154 -> 116 [style=dashed label="for_stmt"]
  154 -> 117 [style=dashed label="inc_dec"]
  154 -> 118 [style=dashed label="print_stmt"]
  154 -> 119 [style=dashed label="scan_stmt"]
  154 -> 120 [style=dashed label="switch_stmt"]
  155 [label="155\nfunc_args -> func_args COMMA expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  155 -> 70 [style=solid label="PLUS"]
  155 -> 71 [style=solid label="MINUS"]
  155 -> 72 [style=solid label="MULT"]
  155 -> 73 [style=solid label="DIVIDE"]
  155 -> 74 [style=solid label="MODULE"]
  156 [label="156\nnum_expr -> LPAREN num_expr RPAREN ."]
  157 [label="157\ndimen_ind_op -> LBRACK ind_op RBRACK dimen_ind_op ."]
  158 [label="158\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr PLUS num_expr .\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr"]
  158 -> 129 [style=solid label="MULT"]
  158 -> 130 [style=solid label="DIVIDE"]
  158 -> 131 [style=solid label="MODULE"]
  159 [label="159\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr MINUS num_expr .\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr"]
  159 -> 129 [style=solid label="MULT"]
  159 -> 130 [style=solid label="DIVIDE"]
  159 -> 131 [style=solid label="MODULE"]
  160 [label="160\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr MULT num_expr .\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr"]
  161 [label="161\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr DIVIDE num_expr .\nnum_expr -> num_expr . MODULE num_expr"]
  162 [label="162\nnum_expr -> num_expr . PLUS num_expr\nnum_expr -> num_expr . MINUS num_expr\nnum_expr -> num_expr . MULT num_expr\nnum_expr -> num_expr . DIVIDE num_expr\nnum_expr -> num_expr . MODULE num_expr\nnum_expr -> num_expr MODULE num_expr ."]
  163 [label="163\nassign_stmt -> ID dimen_ind_op assign_op . expr"]
  163 -> 48 [style=solid label="ID"]
  163 -> 49 [style=solid label="STRING_LITERAL"]
  163 -> 50 [style=solid label="INT_NUMBER"]
  163 -> 51 [style=solid label="DOUBLE_NUMBER"]
  163 -> 52 [style=solid label="TRUE"]
  163 -> 53 [style=solid label="FALSE"]
  163 -> 54 [style=solid label="LPAREN"]
  163 -> 56 [style=dashed label="func_call"]
  163 -> 183 [style=dashed label="expr"]
  164 [label="164\nreturn_stmt -> RETURN expr SEMI_COLON ."]
  165 [label="165\nfunc_call -> ID . LPAREN func_args RPAREN\nexpr -> ID . dimen_ind_op\nc_term -> ID ."]
  165 -> 64 [style=solid label="LPAREN"]
  165 -> 65 [style=solid label="LBRACK"]
  165 -> 66 [style=dashed label="dimen_ind_op"]
  166 [label="166\nexpr -> TRUE .\nc_term -> TRUE ."]
  167 [label="167\nexpr -> FALSE .\nc_term -> FALSE ."]
  168 [label="168\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr\ncomp_term -> expr ."]
  168 -> 70 [style=solid label="PLUS"]
  168 -> 71 [style=solid label="MINUS"]
  168 -> 72 [style=solid label="MULT"]
  168 -> 73 [style=solid label="DIVIDE"]
  168 -> 74 [style=solid label="MODULE"]
  169 [label="169\nwhile_stmt -> WHILE LPAREN condition . RPAREN LBRACE stmt_list RBRACE\ncondition -> condition . logic_op c_term"]
  169 -> 184 [style=solid label="RPAREN"]
  169 -> 185 [style=solid label="AND"]
  169 -> 186 [style=solid label="OR"]
  169 -> 187 [style=solid label="NOT"]
  169 -> 188 [style=dashed label="logic_op"]
  170 [label="170\ncondition -> c_term ."]
  171 [label="171\nc_term -> comp ."]
  172 [label="172\ncomp -> comp_term . comp_op comp_term"]
  172 -> 189 [style=solid label="EQ"]
  172 -> 190 [style=solid label="NEQ"]
  172 -> 191 [style=solid label="LT"]
  172 -> 192 [style=solid label="LE"]
  172 -> 193 [style=solid label="GT"]
  172 -> 194 [style=solid label="GE"]
  172 -> 195 [style=dashed label="comp_op"]
  173 [label="173\nstmt_list -> stmt_list . stmt\nwhile_stmt -> DO LBRACE stmt_list . RBRACE WHILE LPAREN condition RPAREN SEMI_COLON"]
  173 -> 97 [style=solid label="ID"]
  173 -> 1 [style=solid label="INT"]
  173 -> 2 [style=solid label="FLOAT"]
  173 -> 3 [style=solid label="DOUBLE"]
  173 -> 4 [style=solid label="STRING"]
  173 -> 5 [style=solid label="BOOL"]
  173 -> 98 [style=solid label="RETURN"]
  173 -> 99 [style=solid label="WHILE"]
  173 -> 100 [style=solid label="DO"]
  173 -> 101 [style=solid label="IF"]
  173 -> 102 [style=solid label="FOR"]
  173 -> 103 [style=solid label="SWITCH"]
  173 -> 104 [style=solid label="PRINT"]
  173 -> 105 [style=solid label="SCAN"]
  173 -> 196 [style=solid label="RBRACE"]
  173 -> 106 [style=solid label="INCREMENT"]
  173 -> 107 [style=solid label="DECREMENT"]
  173 -> 108 [style=dashed label="decl"]
  173 -> 10 [style=dashed label="type"]
  173 -> 147 [style=dashed label="stmt"]
  173 -> 111 [style=dashed label="func_call"]
  173 -> 112 [style=dashed label="return_stmt"]
  173 -> 113 [style=dashed label="assign_stmt"]
  173 -> 114 [style=dashed label="while_stmt"]
  173 -> 115 [style=dashed label="if_stmt"]
  173 -> 116 [style=dashed label="for_stmt"]
  173 -> 117 [style=dashed label="inc_dec"]
  173 -> 118 [style=dashed label="print_stmt"]
  173 -> 119 [style=dashed label="scan_stmt"]
  173 -> 120 [style=dashed label="switch_stmt"]
  174 [label="174\nif_stmt -> IF LPAREN condition . RPAREN LBRACE stmt_list RBRACE else_stmt_opt\ncondition -> condition . logic_op c_term"]
  174 -> 197 [style=solid label="RPAREN"]
  174 -> 185 [style=solid label="AND"]
  174 -> 186 [style=solid label="OR"]
  174 -> 187 [style=solid label="NOT"]
  174 -> 188 [style=dashed label="logic_op"]
  175 [label="175\nassign_stmt -> ID . dimen_ind_op assign_op expr"]
  175 -> 65 [style=solid label="LBRACK"]
  175 -> 135 [style=dashed label="dimen_ind_op"]
  176 [label="176\nfor_args -> assign_stmt . SEMI_COLON ID comp_op ID SEMI_COLON inc_dec"]
  176 -> 198 [style=solid label="SEMI_COLON"]
  177 [label="177\nfor_stmt -> FOR LPAREN for_args . RPAREN LBRACE stmt_list RBRACE"]
  177 -> 199 [style=solid label="RPAREN"]
  178 [label="178\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr\nswitch_stmt -> SWITCH LPAREN expr . RPAREN LBRACE switch_cases RBRACE"]
  178 -> 200 [style=solid label="RPAREN"]
  178 -> 70 [style=solid label="PLUS"]
  178 -> 71 [style=solid label="MINUS"]
  178 -> 72 [style=solid label="MULT"]
  178 -> 73 [style=solid label="DIVIDE"]
  178 -> 74 [style=solid label="MODULE"]
  179 [label="179\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr\nprint_stmt -> PRINT LPAREN expr . RPAREN"]
  179 -> 201 [style=solid label="RPAREN"]
  179 -> 70 [style=solid label="PLUS"]
  179 -> 71 [style=solid label="MINUS"]
  179 -> 72 [style=solid label="MULT"]
  179 -> 73 [style=solid label="DIVIDE"]
  179 -> 74 [style=solid label="MODULE"]
  180 [label="180\nscan_stmt -> SCAN LPAREN ID . RPAREN"]
  180 -> 202 [style=solid label="RPAREN"]
  181 [label="181\nfunction -> FUNCTION ID LPAREN args_op RPAREN COLON type LBRACE stmt_list . RBRACE\nstmt_list -> stmt_list . stmt"]
  181 -> 97 [style=solid label="ID"]
  181 -> 1 [style=solid label="INT"]
  181 -> 2 [style=solid label="FLOAT"]
  181 -> 3 [style=solid label="DOUBLE"]
  181 -> 4 [style=solid label="STRING"]
  181 -> 5 [style=solid label="BOOL"]
  181 -> 98 [style=solid label="RETURN"]
  181 -> 99 [style=solid label="WHILE"]
  181 -> 100 [style=solid label="DO"]
  181 -> 101 [style=solid label="IF"]
  181 -> 102 [style=solid label="FOR"]
  181 -> 103 [style=solid label="SWITCH"]
  181 -> 104 [style=solid label="PRINT"]
  181 -> 105 [style=solid label="SCAN"]
  181 -> 203 [style=solid label="RBRACE"]
  181 -> 106 [style=solid label="INCREMENT"]
  181 -> 107 [style=solid label="DECREMENT"]
  181 -> 108 [style=dashed label="decl"]
  181 -> 10 [style=dashed label="type"]
  181 -> 147 [style=dashed label="stmt"]
  181 -> 111 [style=dashed label="func_call"]
  181 -> 112 [style=dashed label="return_stmt"]
  181 -> 113 [style=dashed label="assign_stmt"]
  181 -> 114 [style=dashed label="while_stmt"]
  181 -> 115 [style=dashed label="if_stmt"]
  181 -> 116 [style=dashed label="for_stmt"]
  181 -> 117 [style=dashed label="inc_dec"]
  181 -> 118 [style=dashed label="print_stmt"]
  181 -> 119 [style=dashed label="scan_stmt"]
  181 -> 120 [style=dashed label="switch_stmt"]
  182 [label="182\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN COLON type LBRACE stmt_list . RBRACE\nstmt_list -> stmt_list . stmt"]
  182 -> 97 [style=solid label="ID"]
  182 -> 1 [style=solid label="INT"]
  182 -> 2 [style=solid label="FLOAT"]
  182 -> 3 [style=solid label="DOUBLE"]
  182 -> 4 [style=solid label="STRING"]
  182 -> 5 [style=solid label="BOOL"]
  182 -> 98 [style=solid label="RETURN"]
  182 -> 99 [style=solid label="WHILE"]
  182 -> 100 [style=solid label="DO"]
  182 -> 101 [style=solid label="IF"]
  182 -> 102 [style=solid label="FOR"]
  182 -> 103 [style=solid label="SWITCH"]
  182 -> 104 [style=solid label="PRINT"]
  182 -> 105 [style=solid label="SCAN"]
  182 -> 204 [style=solid label="RBRACE"]
  182 -> 106 [style=solid label="INCREMENT"]
  182 -> 107 [style=solid label="DECREMENT"]
  182 -> 108 [style=dashed label="decl"]
  182 -> 10 [style=dashed label="type"]
  182 -> 147 [style=dashed label="stmt"]
  182 -> 111 [style=dashed label="func_call"]
  182 -> 112 [style=dashed label="return_stmt"]
  182 -> 113 [style=dashed label="assign_stmt"]
  182 -> 114 [style=dashed label="while_stmt"]
  182 -> 115 [style=dashed label="if_stmt"]
  182 -> 116 [style=dashed label="for_stmt"]
  182 -> 117 [style=dashed label="inc_dec"]
  182 -> 118 [style=dashed label="print_stmt"]
  182 -> 119 [style=dashed label="scan_stmt"]
  182 -> 120 [style=dashed label="switch_stmt"]
  183 [label="183\nassign_stmt -> ID dimen_ind_op assign_op expr .\nexpr -> expr . PLUS expr\nexpr -> expr . MINUS expr\nexpr -> expr . MULT expr\nexpr -> expr . DIVIDE expr\nexpr -> expr . MODULE expr"]
  183 -> 70 [style=solid label="PLUS"]
  183 -> 71 [style=solid label="MINUS"]
  183 -> 72 [style=solid label="MULT"]
  183 -> 73 [style=solid label="DIVIDE"]
  183 -> 74 [style=solid label="MODULE"]
  184 [label="184\nwhile_stmt -> WHILE LPAREN condition RPAREN . LBRACE stmt_list RBRACE"]
  184 -> 205 [style=solid label="LBRACE"]
  185 [label="185\nlogic_op -> AND ."]
  186 [label="186\nlogic_op -> OR ."]
  187 [label="187\nlogic_op -> NOT ."]
  188 [label="188\ncondition -> condition logic_op . c_term"]
  188 -> 165 [style=solid label="ID"]
  188 -> 49 [style=solid label="STRING_LITERAL"]
  188 -> 50 [style=solid label="INT_NUMBER"]
  188 -> 51 [style=solid label="DOUBLE_NUMBER"]
  188 -> 166 [style=solid label="TRUE"]
  188 -> 167 [style=solid label="FALSE"]
  188 -> 54 [style=solid label="LPAREN"]
  188 -> 56 [style=dashed label="func_call"]
  188 -> 168 [style=dashed label="expr"]
  188 -> 206 [style=dashed label="c_term"]
  188 -> 171 [style=dashed label="comp"]
  188 -> 172 [style=dashed label="comp_term"]
  189 [label="189\ncomp_op -> EQ ."]
  190 [label="190\ncomp_op -> NEQ ."]
  191 [label="191\ncomp_op -> LT ."]
  192 [label="192\ncomp_op -> LE ."]
  193 [label="193\ncomp_op -> GT ."]
  194 [label="194\ncomp_op -> GE ."]
  195 [label="195\ncomp -> comp_term comp_op . comp_term"]
  195 -> 48 [style=solid label="ID"]
  195 -> 49 [style=solid label="STRING_LITERAL"]
  195 -> 50 [style=solid label="INT_NUMBER"]
  195 -> 51 [style=solid label="DOUBLE_NUMBER"]
  195 -> 52 [style=solid label="TRUE"]
  195 -> 53 [style=solid label="FALSE"]
  195 -> 54 [style=solid label="LPAREN"]
  195 -> 56 [style=dashed label="func_call"]
  195 -> 168 [style=dashed label="expr"]
  195 -> 207 [style=dashed label="comp_term"]
  196 [label="196\nwhile_stmt -> DO LBRACE stmt_list RBRACE . WHILE LPAREN condition RPAREN SEMI_COLON"]
  196 -> 208 [style=solid label="WHILE"]
  197 [label="197\nif_stmt -> IF LPAREN condition RPAREN . LBRACE stmt_list RBRACE else_stmt_opt"]
  197 -> 209 [style=solid label="LBRACE"]
  198 [label="198\nfor_args -> assign_stmt SEMI_COLON . ID comp_op ID SEMI_COLON inc_dec"]
  198 -> 210 [style=solid label="ID"]
  199 [label="199\nfor_stmt -> FOR LPAREN for_args RPAREN . LBRACE stmt_list RBRACE"]
  199 -> 211 [style=solid label="LBRACE"]
  200 [label="200\nswitch_stmt -> SWITCH LPAREN expr RPAREN . LBRACE switch_cases RBRACE"]
  200 -> 212 [style=solid label="LBRACE"]
  201 [label="201\nprint_stmt -> PRINT LPAREN expr RPAREN ."]
  202 [label="202\nscan_stmt -> SCAN LPAREN ID RPAREN ."]
  203 [label="203\nfunction -> FUNCTION ID LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE ."]
  204 [label="204\nfunction -> FUNCTION MAIN LPAREN args_op RPAREN COLON type LBRACE stmt_list RBRACE ."]
  205 [label="205\nwhile_stmt -> WHILE LPAREN condition RPAREN LBRACE . stmt_list RBRACE"]
  205 -> 97 [style=solid label="ID"]
  205 -> 1 [style=solid label="INT"]
  205 -> 2 [style=solid label="FLOAT"]
  205 -> 3 [style=solid label="DOUBLE"]
  205 -> 4 [style=solid label="STRING"]
  205 -> 5 [style=solid label="BOOL"]
  205 -> 98 [style=solid label="RETURN"]
  205 -> 99 [style=solid label="WHILE"]
  205 -> 100 [style=solid label="DO"]
  205 -> 101 [style=solid label="IF"]
  205 -> 102 [style=solid label="FOR"]
  205 -> 103 [style=solid label="SWITCH"]
  205 -> 104 [style=solid label="PRINT"]
  205 -> 105 [style=solid label="SCAN"]
  205 -> 106 [style=solid label="INCREMENT"]
  205 -> 107 [style=solid label="DECREMENT"]
  205 -> 108 [style=dashed label="decl"]
  205 -> 10 [style=dashed label="type"]
  205 -> 213 [style=dashed label="stmt_list"]
  205 -> 110 [style=dashed label="stmt"]
  205 -> 111 [style=dashed label="func_call"]
  205 -> 112 [style=dashed label="return_stmt"]
  205 -> 113 [style=dashed label="assign_stmt"]
  205 -> 114 [style=dashed label="while_stmt"]
  205 -> 115 [style=dashed label="if_stmt"]
  205 -> 116 [style=dashed label="for_stmt"]
  205 -> 117 [style=dashed label="inc_dec"]
  205 -> 118 [style=dashed label="print_stmt"]
  205 -> 119 [style=dashed label="scan_stmt"]
  205 -> 120 [style=dashed label="switch_stmt"]
  206 [label="206\ncondition -> condition logic_op c_term ."]
  207 [label="207\ncomp -> comp_term comp_op comp_term ."]
  208 [label="208\nwhile_stmt -> DO LBRACE stmt_list RBRACE WHILE . LPAREN condition RPAREN SEMI_COLON"]
  208 -> 214 [style=solid label="LPAREN"]
  209 [label="209\nif_stmt -> IF LPAREN condition RPAREN LBRACE . stmt_list RBRACE else_stmt_opt"]
  209 -> 97 [style=solid label="ID"]
  209 -> 1 [style=solid label="INT"]
  209 -> 2 [style=solid label="FLOAT"]
  209 -> 3 [style=solid label="DOUBLE"]
  209 -> 4 [style=solid label="STRING"]
  209 -> 5 [style=solid label="BOOL"]
  209 -> 98 [style=solid label="RETURN"]
  209 -> 99 [style=solid label="WHILE"]
  209 -> 100 [style=solid label="DO"]
  209 -> 101 [style=solid label="IF"]
  209 -> 102 [style=solid label="FOR"]
  209 -> 103 [style=solid label="SWITCH"]
  209 -> 104 [style=solid label="PRINT"]
  209 -> 105 [style=solid label="SCAN"]
  209 -> 106 [style=solid label="INCREMENT"]
  209 -> 107 [style=solid label="DECREMENT"]
  209 -> 108 [style=dashed label="decl"]
  209 -> 10 [style=dashed label="type"]
  209 -> 215 [style=dashed label="stmt_list"]
  209 -> 110 [style=dashed label="stmt"]
  209 -> 111 [style=dashed label="func_call"]
  209 -> 112 [style=dashed label="return_stmt"]
  209 -> 113 [style=dashed label="assign_stmt"]
  209 -> 114 [style=dashed label="while_stmt"]
  209 -> 115 [style=dashed label="if_stmt"]
  209 -> 116 [style=dashed label="for_stmt"]
  209 -> 117 [style=dashed label="inc_dec"]
  209 -> 118 [style=dashed label="print_stmt"]
  209 -> 119 [style=dashed label="scan_stmt"]
  209 -> 120 [style=dashed label="switch_stmt"]
  210 [label="210\nfor_args -> assign_stmt SEMI_COLON ID . comp_op ID SEMI_COLON inc_dec"]
  210 -> 189 [style=solid label="EQ"]
  210 -> 190 [style=solid label="NEQ"]
  210 -> 191 [style=solid label="LT"]
  210 -> 192 [style=solid label="LE"]
  210 -> 193 [style=solid label="GT"]
  210 -> 194 [style=solid label="GE"]
  210 -> 216 [style=dashed label="comp_op"]
  211 [label="211\nfor_stmt -> FOR LPAREN for_args RPAREN LBRACE . stmt_list RBRACE"]
  211 -> 97 [style=solid label="ID"]
  211 -> 1 [style=solid label="INT"]
  211 -> 2 [style=solid label="FLOAT"]
  211 -> 3 [style=solid label="DOUBLE"]
  211 -> 4 [style=solid label="STRING"]
  211 -> 5 [style=solid label="BOOL"]
  211 -> 98 [style=solid label="RETURN"]
  211 -> 99 [style=solid label="WHILE"]
  211 -> 100 [style=solid label="DO"]
  211 -> 101 [style=solid label="IF"]
  211 -> 102 [style=solid label="FOR"]
  211 -> 103 [style=solid label="SWITCH"]
  211 -> 104 [style=solid label="PRINT"]
  211 -> 105 [style=solid label="SCAN"]
  211 -> 106 [style=solid label="INCREMENT"]
  211 -> 107 [style=solid label="DECREMENT"]
  211 -> 108 [style=dashed label="decl"]
  211 -> 10 [style=dashed label="type"]
  211 -> 217 [style=dashed label="stmt_list"]
  211 -> 110 [style=dashed label="stmt"]
  211 -> 111 [style=dashed label="func_call"]
  211 -> 112 [style=dashed label="return_stmt"]
  211 -> 113 [style=dashed label="assign_stmt"]
  211 -> 114 [style=dashed label="while_stmt"]
  211 -> 115 [style=dashed label="if_stmt"]
  211 -> 116 [style=dashed label="for_stmt"]
  211 -> 117 [style=dashed label="inc_dec"]
  211 -> 118 [style=dashed label="print_stmt"]
  211 -> 119 [style=dashed label="scan_stmt"]
  211 -> 120 [style=dashed label="switch_stmt"]
  212 [label="212\nswitch_stmt -> SWITCH LPAREN expr RPAREN LBRACE . switch_cases RBRACE"]
  212 -> 218 [style=solid label="CASE"]
  212 -> 219 [style=dashed label="switch_cases"]
  212 -> 220 [style=dashed label="case"]
  213 [label="213\nstmt_list -> stmt_list . stmt\nwhile_stmt -> WHILE LPAREN condition RPAREN LBRACE stmt_list . RBRACE"]
  213 -> 97 [style=solid label="ID"]
  213 -> 1 [style=solid label="INT"]
  213 -> 2 [style=solid label="FLOAT"]
  213 -> 3 [style=solid label="DOUBLE"]
  213 -> 4 [style=solid label="STRING"]
  213 -> 5 [style=solid label="BOOL"]
  213 -> 98 [style=solid label="RETURN"]
  213 -> 99 [style=solid label="WHILE"]
  213 -> 100 [style=solid label="DO"]
  213 -> 101 [style=solid label="IF"]
  213 -> 102 [style=solid label="FOR"]
  213 -> 103 [style=solid label="SWITCH"]
  213 -> 104 [style=solid label="PRINT"]
  213 -> 105 [style=solid label="SCAN"]
  213 -> 221 [style=solid label="RBRACE"]
  213 -> 106 [style=solid label="INCREMENT"]
  213 -> 107 [style=solid label="DECREMENT"]
  213 -> 108 [style=dashed label="decl"]
  213 -> 10 [style=dashed label="type"]
  213 -> 147 [style=dashed label="stmt"]
  213 -> 111 [style=dashed label="func_call"]
  213 -> 112 [style=dashed label="return_stmt"]
  213 -> 113 [style=dashed label="assign_stmt"]
  213 -> 114 [style=dashed label="while_stmt"]
  213 -> 115 [style=dashed label="if_stmt"]
  213 -> 116 [style=dashed label="for_stmt"]
  213 -> 117 [style=dashed label="inc_dec"]
  213 -> 118 [style=dashed label="print_stmt"]
  213 -> 119 [style=dashed label="scan_stmt"]
  213 -> 120 [style=dashed label="switch_stmt"]
  214 [label="214\nwhile_stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN . condition RPAREN SEMI_COLON"]
  214 -> 165 [style=solid label="ID"]
  214 -> 49 [style=solid label="STRING_LITERAL"]
  214 -> 50 [style=solid label="INT_NUMBER"]
  214 -> 51 [style=solid label="DOUBLE_NUMBER"]
  214 -> 166 [style=solid label="TRUE"]
  214 -> 167 [style=solid label="FALSE"]
  214 -> 54 [style=solid label="LPAREN"]
  214 -> 56 [style=dashed label="func_call"]
  214 -> 168 [style=dashed label="expr"]
  214 -> 222 [style=dashed label="condition"]
  214 -> 170 [style=dashed label="c_term"]
  214 -> 171 [style=dashed label="comp"]
  214 -> 172 [style=dashed label="comp_term"]
  215 [label="215\nstmt_list -> stmt_list . stmt\nif_stmt -> IF LPAREN condition RPAREN LBRACE stmt_list . RBRACE else_stmt_opt"]
  215 -> 97 [style=solid label="ID"]
  215 -> 1 [style=solid label="INT"]
  215 -> 2 [style=solid label="FLOAT"]
  215 -> 3 [style=solid label="DOUBLE"]
  215 -> 4 [style=solid label="STRING"]
  215 -> 5 [style=solid label="BOOL"]
  215 -> 98 [style=solid label="RETURN"]
  215 -> 99 [style=solid label="WHILE"]
  215 -> 100 [style=solid label="DO"]
  215 -> 101 [style=solid label="IF"]
  215 -> 102 [style=solid label="FOR"]
  215 -> 103 [style=solid label="SWITCH"]
  215 -> 104 [style=solid label="PRINT"]
  215 -> 105 [style=solid label="SCAN"]
  215 -> 223 [style=solid label="RBRACE"]
  215 -> 106 [style=solid label="INCREMENT"]
  215 -> 107 [style=solid label="DECREMENT"]
  215 -> 108 [style=dashed label="decl"]
  215 -> 10 [style=dashed label="type"]
  215 -> 147 [style=dashed label="stmt"]
  215 -> 111 [style=dashed label="func_call"]
  215 -> 112 [style=dashed label="return_stmt"]
  215 -> 113 [style=dashed label="assign_stmt"]
  215 -> 114 [style=dashed label="while_stmt"]
  215 -> 115 [style=dashed label="if_stmt"]
  215 -> 116 [style=dashed label="for_stmt"]
  215 -> 117 [style=dashed label="inc_dec"]
  215 -> 118 [style=dashed label="print_stmt"]
  215 -> 119 [style=dashed label="scan_stmt"]
  215 -> 120 [style=dashed label="switch_stmt"]
  216 [label="216\nfor_args -> assign_stmt SEMI_COLON ID comp_op . ID SEMI_COLON inc_dec"]
  216 -> 224 [style=solid label="ID"]
  217 [label="217\nstmt_list -> stmt_list . stmt\nfor_stmt -> FOR LPAREN for_args RPAREN LBRACE stmt_list . RBRACE"]
  217 -> 97 [style=solid label="ID"]
  217 -> 1 [style=solid label="INT"]
  217 -> 2 [style=solid label="FLOAT"]
  217 -> 3 [style=solid label="DOUBLE"]
  217 -> 4 [style=solid label="STRING"]
  217 -> 5 [style=solid label="BOOL"]
  217 -> 98 [style=solid label="RETURN"]
  217 -> 99 [style=solid label="WHILE"]
  217 -> 100 [style=solid label="DO"]
  217 -> 101 [style=solid label="IF"]
  217 -> 102 [style=solid label="FOR"]
  217 -> 103 [style=solid label="SWITCH"]
  217 -> 104 [style=solid label="PRINT"]
  217 -> 105 [style=solid label="SCAN"]
  217 -> 225 [style=solid label="RBRACE"]
  217 -> 106 [style=solid label="INCREMENT"]
  217 -> 107 [style=solid label="DECREMENT"]
  217 -> 108 [style=dashed label="decl"]
  217 -> 10 [style=dashed label="type"]
  217 -> 147 [style=dashed label="stmt"]
  217 -> 111 [style=dashed label="func_call"]
  217 -> 112 [style=dashed label="return_stmt"]
  217 -> 113 [style=dashed label="assign_stmt"]
  217 -> 114 [style=dashed label="while_stmt"]
  217 -> 115 [style=dashed label="if_stmt"]
  217 -> 116 [style=dashed label="for_stmt"]
  217 -> 117 [style=dashed label="inc_dec"]
  217 -> 118 [style=dashed label="print_stmt"]
  217 -> 119 [style=dashed label="scan_stmt"]
  217 -> 120 [style=dashed label="switch_stmt"]
  218 [label="218\ncase -> CASE . INT_NUMBER COLON stmt_list BREAK SEMI_COLON\ncase -> CASE . DOUBLE_NUMBER COLON stmt_list BREAK SEMI_COLON\ncase -> CASE . STRING_LITERAL COLON stmt_list BREAK SEMI_COLON\ncase -> CASE . TRUE COLON stmt_list BREAK SEMI_COLON\ncase -> CASE . FALSE COLON stmt_list BREAK SEMI_COLON"]
  218 -> 226 [style=solid label="STRING_LITERAL"]
  218 -> 227 [style=solid label="INT_NUMBER"]
  218 -> 228 [style=solid label="DOUBLE_NUMBER"]
  218 -> 229 [style=solid label="TRUE"]
  218 -> 230 [style=solid label="FALSE"]
  219 [label="219\nswitch_stmt -> SWITCH LPAREN expr RPAREN LBRACE switch_cases . RBRACE\nswitch_cases -> switch_cases . case"]
  219 -> 218 [style=solid label="CASE"]
  219 -> 231 [style=solid label="RBRACE"]
  219 -> 232 [style=dashed label="case"]
  220 [label="220\nswitch_cases -> case ."]
  221 [label="221\nwhile_stmt -> WHILE LPAREN condition RPAREN LBRACE stmt_list RBRACE ."]
  222 [label="222\nwhile_stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN condition . RPAREN SEMI_COLON\ncondition -> condition . logic_op c_term"]
  222 -> 233 [style=solid label="RPAREN"]
  222 -> 185 [style=solid label="AND"]
  222 -> 186 [style=solid label="OR"]
  222 -> 187 [style=solid label="NOT"]
  222 -> 188 [style=dashed label="logic_op"]
  223 [label="223\nif_stmt -> IF LPAREN condition RPAREN LBRACE stmt_list RBRACE . else_stmt_opt"]
  223 -> 234 [style=solid label="ELSE"]
  223 -> 235 [style=dashed label="else_stmt_opt"]
  224 [label="224\nfor_args -> assign_stmt SEMI_COLON ID comp_op ID . SEMI_COLON inc_dec"]
  224 -> 236 [style=solid label="SEMI_COLON"]
  225 [label="225\nfor_stmt -> FOR LPAREN for_args RPAREN LBRACE stmt_list RBRACE ."]
  226 [label="226\ncase -> CASE STRING_LITERAL . COLON stmt_list BREAK SEMI_COLON"]
  226 -> 237 [style=solid label="COLON"]
  227 [label="227\ncase -> CASE INT_NUMBER . COLON stmt_list BREAK SEMI_COLON"]
  227 -> 238 [style=solid label="COLON"]
  228 [label="228\ncase -> CASE DOUBLE_NUMBER . COLON stmt_list BREAK SEMI_COLON"]
  228 -> 239 [style=solid label="COLON"]
  229 [label="229\ncase -> CASE TRUE . COLON stmt_list BREAK SEMI_COLON"]
  229 -> 240 [style=solid label="COLON"]
  230 [label="230\ncase -> CASE FALSE . COLON stmt_list BREAK SEMI_COLON"]
  230 -> 241 [style=solid label="COLON"]
  231 [label="231\nswitch_stmt -> SWITCH LPAREN expr RPAREN LBRACE switch_cases RBRACE ."]
  232 [label="232\nswitch_cases -> switch_cases case ."]
  233 [label="233\nwhile_stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN condition RPAREN . SEMI_COLON"]
  233 -> 242 [style=solid label="SEMI_COLON"]
  234 [label="234\nelse_stmt_opt -> ELSE . LBRACE stmt_list RBRACE"]
  234 -> 243 [style=solid label="LBRACE"]
  235 [label="235\nif_stmt -> IF LPAREN condition RPAREN LBRACE stmt_list RBRACE else_stmt_opt ."]
  236 [label="236\nfor_args -> assign_stmt SEMI_COLON ID comp_op ID SEMI_COLON . inc_dec"]
  236 -> 244 [style=solid label="ID"]
  236 -> 106 [style=solid label="INCREMENT"]
  236 -> 107 [style=solid label="DECREMENT"]
  236 -> 245 [style=dashed label="inc_dec"]
  237 [label="237\ncase -> CASE STRING_LITERAL COLON . stmt_list BREAK SEMI_COLON"]
  237 -> 97 [style=solid label="ID"]
  237 -> 1 [style=solid label="INT"]
  237 -> 2 [style=solid label="FLOAT"]
  237 -> 3 [style=solid label="DOUBLE"]
  237 -> 4 [style=solid label="STRING"]
  237 -> 5 [style=solid label="BOOL"]
  237 -> 98 [style=solid label="RETURN"]
  237 -> 99 [style=solid label="WHILE"]
  237 -> 100 [style=solid label="DO"]
  237 -> 101 [style=solid label="IF"]
  237 -> 102 [style=solid label="FOR"]
  237 -> 103 [style=solid label="SWITCH"]
  237 -> 104 [style=solid label="PRINT"]
  237 -> 105 [style=solid label="SCAN"]
  237 -> 106 [style=solid label="INCREMENT"]
  237 -> 107 [style=solid label="DECREMENT"]
  237 -> 108 [style=dashed label="decl"]
  237 -> 10 [style=dashed label="type"]
  237 -> 246 [style=dashed label="stmt_list"]
  237 -> 110 [style=dashed label="stmt"]
  237 -> 111 [style=dashed label="func_call"]
  237 -> 112 [style=dashed label="return_stmt"]
  237 -> 113 [style=dashed label="assign_stmt"]
  237 -> 114 [style=dashed label="while_stmt"]
  237 -> 115 [style=dashed label="if_stmt"]
  237 -> 116 [style=dashed label="for_stmt"]
  237 -> 117 [style=dashed label="inc_dec"]
  237 -> 118 [style=dashed label="print_stmt"]
  237 -> 119 [style=dashed label="scan_stmt"]
  237 -> 120 [style=dashed label="switch_stmt"]
  238 [label="238\ncase -> CASE INT_NUMBER COLON . stmt_list BREAK SEMI_COLON"]
  238 -> 97 [style=solid label="ID"]
  238 -> 1 [style=solid label="INT"]
  238 -> 2 [style=solid label="FLOAT"]
  238 -> 3 [style=solid label="DOUBLE"]
  238 -> 4 [style=solid label="STRING"]
  238 -> 5 [style=solid label="BOOL"]
  238 -> 98 [style=solid label="RETURN"]
  238 -> 99 [style=solid label="WHILE"]
  238 -> 100 [style=solid label="DO"]
  238 -> 101 [style=solid label="IF"]
  238 -> 102 [style=solid label="FOR"]
  238 -> 103 [style=solid label="SWITCH"]
  238 -> 104 [style=solid label="PRINT"]
  238 -> 105 [style=solid label="SCAN"]
  238 -> 106 [style=solid label="INCREMENT"]
  238 -> 107 [style=solid label="DECREMENT"]
  238 -> 108 [style=dashed label="decl"]
  238 -> 10 [style=dashed label="type"]
  238 -> 247 [style=dashed label="stmt_list"]
  238 -> 110 [style=dashed label="stmt"]
  238 -> 111 [style=dashed label="func_call"]
  238 -> 112 [style=dashed label="return_stmt"]
  238 -> 113 [style=dashed label="assign_stmt"]
  238 -> 114 [style=dashed label="while_stmt"]
  238 -> 115 [style=dashed label="if_stmt"]
  238 -> 116 [style=dashed label="for_stmt"]
  238 -> 117 [style=dashed label="inc_dec"]
  238 -> 118 [style=dashed label="print_stmt"]
  238 -> 119 [style=dashed label="scan_stmt"]
  238 -> 120 [style=dashed label="switch_stmt"]
  239 [label="239\ncase -> CASE DOUBLE_NUMBER COLON . stmt_list BREAK SEMI_COLON"]
  239 -> 97 [style=solid label="ID"]
  239 -> 1 [style=solid label="INT"]
  239 -> 2 [style=solid label="FLOAT"]
  239 -> 3 [style=solid label="DOUBLE"]
  239 -> 4 [style=solid label="STRING"]
  239 -> 5 [style=solid label="BOOL"]
  239 -> 98 [style=solid label="RETURN"]
  239 -> 99 [style=solid label="WHILE"]
  239 -> 100 [style=solid label="DO"]
  239 -> 101 [style=solid label="IF"]
  239 -> 102 [style=solid label="FOR"]
  239 -> 103 [style=solid label="SWITCH"]
  239 -> 104 [style=solid label="PRINT"]
  239 -> 105 [style=solid label="SCAN"]
  239 -> 106 [style=solid label="INCREMENT"]
  239 -> 107 [style=solid label="DECREMENT"]
  239 -> 108 [style=dashed label="decl"]
  239 -> 10 [style=dashed label="type"]
  239 -> 248 [style=dashed label="stmt_list"]
  239 -> 110 [style=dashed label="stmt"]
  239 -> 111 [style=dashed label="func_call"]
  239 -> 112 [style=dashed label="return_stmt"]
  239 -> 113 [style=dashed label="assign_stmt"]
  239 -> 114 [style=dashed label="while_stmt"]
  239 -> 115 [style=dashed label="if_stmt"]
  239 -> 116 [style=dashed label="for_stmt"]
  239 -> 117 [style=dashed label="inc_dec"]
  239 -> 118 [style=dashed label="print_stmt"]
  239 -> 119 [style=dashed label="scan_stmt"]
  239 -> 120 [style=dashed label="switch_stmt"]
  240 [label="240\ncase -> CASE TRUE COLON . stmt_list BREAK SEMI_COLON"]
  240 -> 97 [style=solid label="ID"]
  240 -> 1 [style=solid label="INT"]
  240 -> 2 [style=solid label="FLOAT"]
  240 -> 3 [style=solid label="DOUBLE"]
  240 -> 4 [style=solid label="STRING"]
  240 -> 5 [style=solid label="BOOL"]
  240 -> 98 [style=solid label="RETURN"]
  240 -> 99 [style=solid label="WHILE"]
  240 -> 100 [style=solid label="DO"]
  240 -> 101 [style=solid label="IF"]
  240 -> 102 [style=solid label="FOR"]
  240 -> 103 [style=solid label="SWITCH"]
  240 -> 104 [style=solid label="PRINT"]
  240 -> 105 [style=solid label="SCAN"]
  240 -> 106 [style=solid label="INCREMENT"]
  240 -> 107 [style=solid label="DECREMENT"]
  240 -> 108 [style=dashed label="decl"]
  240 -> 10 [style=dashed label="type"]
  240 -> 249 [style=dashed label="stmt_list"]
  240 -> 110 [style=dashed label="stmt"]
  240 -> 111 [style=dashed label="func_call"]
  240 -> 112 [style=dashed label="return_stmt"]
  240 -> 113 [style=dashed label="assign_stmt"]
  240 -> 114 [style=dashed label="while_stmt"]
  240 -> 115 [style=dashed label="if_stmt"]
  240 -> 116 [style=dashed label="for_stmt"]
  240 -> 117 [style=dashed label="inc_dec"]
  240 -> 118 [style=dashed label="print_stmt"]
  240 -> 119 [style=dashed label="scan_stmt"]
  240 -> 120 [style=dashed label="switch_stmt"]
  241 [label="241\ncase -> CASE FALSE COLON . stmt_list BREAK SEMI_COLON"]
  241 -> 97 [style=solid label="ID"]
  241 -> 1 [style=solid label="INT"]
  241 -> 2 [style=solid label="FLOAT"]
  241 -> 3 [style=solid label="DOUBLE"]
  241 -> 4 [style=solid label="STRING"]
  241 -> 5 [style=solid label="BOOL"]
  241 -> 98 [style=solid label="RETURN"]
  241 -> 99 [style=solid label="WHILE"]
  241 -> 100 [style=solid label="DO"]
  241 -> 101 [style=solid label="IF"]
  241 -> 102 [style=solid label="FOR"]
  241 -> 103 [style=solid label="SWITCH"]
  241 -> 104 [style=solid label="PRINT"]
  241 -> 105 [style=solid label="SCAN"]
  241 -> 106 [style=solid label="INCREMENT"]
  241 -> 107 [style=solid label="DECREMENT"]
  241 -> 108 [style=dashed label="decl"]
  241 -> 10 [style=dashed label="type"]
  241 -> 250 [style=dashed label="stmt_list"]
  241 -> 110 [style=dashed label="stmt"]
  241 -> 111 [style=dashed label="func_call"]
  241 -> 112 [style=dashed label="return_stmt"]
  241 -> 113 [style=dashed label="assign_stmt"]
  241 -> 114 [style=dashed label="while_stmt"]
  241 -> 115 [style=dashed label="if_stmt"]
  241 -> 116 [style=dashed label="for_stmt"]
  241 -> 117 [style=dashed label="inc_dec"]
  241 -> 118 [style=dashed label="print_stmt"]
  241 -> 119 [style=dashed label="scan_stmt"]
  241 -> 120 [style=dashed label="switch_stmt"]
  242 [label="242\nwhile_stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN condition RPAREN SEMI_COLON ."]
  243 [label="243\nelse_stmt_opt -> ELSE LBRACE . stmt_list RBRACE"]
  243 -> 97 [style=solid label="ID"]
  243 -> 1 [style=solid label="INT"]
  243 -> 2 [style=solid label="FLOAT"]
  243 -> 3 [style=solid label="DOUBLE"]
  243 -> 4 [style=solid label="STRING"]
  243 -> 5 [style=solid label="BOOL"]
  243 -> 98 [style=solid label="RETURN"]
  243 -> 99 [style=solid label="WHILE"]
  243 -> 100 [style=solid label="DO"]
  243 -> 101 [style=solid label="IF"]
  243 -> 102 [style=solid label="FOR"]
  243 -> 103 [style=solid label="SWITCH"]
  243 -> 104 [style=solid label="PRINT"]
  243 -> 105 [style=solid label="SCAN"]
  243 -> 106 [style=solid label="INCREMENT"]
  243 -> 107 [style=solid label="DECREMENT"]
  243 -> 108 [style=dashed label="decl"]
  243 -> 10 [style=dashed label="type"]
  243 -> 251 [style=dashed label="stmt_list"]
  243 -> 110 [style=dashed label="stmt"]
  243 -> 111 [style=dashed label="func_call"]
  243 -> 112 [style=dashed label="return_stmt"]
  243 -> 113 [style=dashed label="assign_stmt"]
  243 -> 114 [style=dashed label="while_stmt"]
  243 -> 115 [style=dashed label="if_stmt"]
  243 -> 116 [style=dashed label="for_stmt"]
  243 -> 117 [style=dashed label="inc_dec"]
  243 -> 118 [style=dashed label="print_stmt"]
  243 -> 119 [style=dashed label="scan_stmt"]
  243 -> 120 [style=dashed label="switch_stmt"]
  244 [label="244\ninc_dec -> ID . INCREMENT\ninc_dec -> ID . DECREMENT"]
  244 -> 133 [style=solid label="INCREMENT"]
  244 -> 134 [style=solid label="DECREMENT"]
  245 [label="245\nfor_args -> assign_stmt SEMI_COLON ID comp_op ID SEMI_COLON inc_dec ."]
  246 [label="246\nstmt_list -> stmt_list . stmt\ncase -> CASE STRING_LITERAL COLON stmt_list . BREAK SEMI_COLON"]
  246 -> 97 [style=solid label="ID"]
  246 -> 1 [style=solid label="INT"]
  246 -> 2 [style=solid label="FLOAT"]
  246 -> 3 [style=solid label="DOUBLE"]
  246 -> 4 [style=solid label="STRING"]
  246 -> 5 [style=solid label="BOOL"]
  246 -> 98 [style=solid label="RETURN"]
  246 -> 99 [style=solid label="WHILE"]
  246 -> 100 [style=solid label="DO"]
  246 -> 101 [style=solid label="IF"]
  246 -> 102 [style=solid label="FOR"]
  246 -> 103 [style=solid label="SWITCH"]
  246 -> 252 [style=solid label="BREAK"]
  246 -> 104 [style=solid label="PRINT"]
  246 -> 105 [style=solid label="SCAN"]
  246 -> 106 [style=solid label="INCREMENT"]
  246 -> 107 [style=solid label="DECREMENT"]
  246 -> 108 [style=dashed label="decl"]
  246 -> 10 [style=dashed label="type"]
  246 -> 147 [style=dashed label="stmt"]
  246 -> 111 [style=dashed label="func_call"]
  246 -> 112 [style=dashed label="return_stmt"]
  246 -> 113 [style=dashed label="assign_stmt"]
  246 -> 114 [style=dashed label="while_stmt"]
  246 -> 115 [style=dashed label="if_stmt"]
  246 -> 116 [style=dashed label="for_stmt"]
  246 -> 117 [style=dashed label="inc_dec"]
  246 -> 118 [style=dashed label="print_stmt"]
  246 -> 119 [style=dashed label="scan_stmt"]
  246 -> 120 [style=dashed label="switch_stmt"]
  247 [label="247\nstmt_list -> stmt_list . stmt\ncase -> CASE INT_NUMBER COLON stmt_list . BREAK SEMI_COLON"]
  247 -> 97 [style=solid label="ID"]
  247 -> 1 [style=solid label="INT"]
  247 -> 2 [style=solid label="FLOAT"]
  247 -> 3 [style=solid label="DOUBLE"]
  247 -> 4 [style=solid label="STRING"]
  247 -> 5 [style=solid label="BOOL"]
  247 -> 98 [style=solid label="RETURN"]
  247 -> 99 [style=solid label="WHILE"]
  247 -> 100 [style=solid label="DO"]
  247 -> 101 [style=solid label="IF"]
  247 -> 102 [style=solid label="FOR"]
  247 -> 103 [style=solid label="SWITCH"]
  247 -> 253 [style=solid label="BREAK"]
  247 -> 104 [style=solid label="PRINT"]
  247 -> 105 [style=solid label="SCAN"]
  247 -> 106 [style=solid label="INCREMENT"]
  247 -> 107 [style=solid label="DECREMENT"]
  247 -> 108 [style=dashed label="decl"]
  247 -> 10 [style=dashed label="type"]
  247 -> 147 [style=dashed label="stmt"]
  247 -> 111 [style=dashed label="func_call"]
  247 -> 112 [style=dashed label="return_stmt"]
  247 -> 113 [style=dashed label="assign_stmt"]
  247 -> 114 [style=dashed label="while_stmt"]
  247 -> 115 [style=dashed label="if_stmt"]
  247 -> 116 [style=dashed label="for_stmt"]
  247 -> 117 [style=dashed label="inc_dec"]
  247 -> 118 [style=dashed label="print_stmt"]
  247 -> 119 [style=dashed label="scan_stmt"]
  247 -> 120 [style=dashed label="switch_stmt"]
  248 [label="248\nstmt_list -> stmt_list . stmt\ncase -> CASE DOUBLE_NUMBER COLON stmt_list . BREAK SEMI_COLON"]
  248 -> 97 [style=solid label="ID"]
  248 -> 1 [style=solid label="INT"]
  248 -> 2 [style=solid label="FLOAT"]
  248 -> 3 [style=solid label="DOUBLE"]
  248 -> 4 [style=solid label="STRING"]
  248 -> 5 [style=solid label="BOOL"]
  248 -> 98 [style=solid label="RETURN"]
  248 -> 99 [style=solid label="WHILE"]
  248 -> 100 [style=solid label="DO"]
  248 -> 101 [style=solid label="IF"]
  248 -> 102 [style=solid label="FOR"]
  248 -> 103 [style=solid label="SWITCH"]
  248 -> 254 [style=solid label="BREAK"]
  248 -> 104 [style=solid label="PRINT"]
  248 -> 105 [style=solid label="SCAN"]
  248 -> 106 [style=solid label="INCREMENT"]
  248 -> 107 [style=solid label="DECREMENT"]
  248 -> 108 [style=dashed label="decl"]
  248 -> 10 [style=dashed label="type"]
  248 -> 147 [style=dashed label="stmt"]
  248 -> 111 [style=dashed label="func_call"]
  248 -> 112 [style=dashed label="return_stmt"]
  248 -> 113 [style=dashed label="assign_stmt"]
  248 -> 114 [style=dashed label="while_stmt"]
  248 -> 115 [style=dashed label="if_stmt"]
  248 -> 116 [style=dashed label="for_stmt"]
  248 -> 117 [style=dashed label="inc_dec"]
  248 -> 118 [style=dashed label="print_stmt"]
  248 -> 119 [style=dashed label="scan_stmt"]
  248 -> 120 [style=dashed label="switch_stmt"]
  249 [label="249\nstmt_list -> stmt_list . stmt\ncase -> CASE TRUE COLON stmt_list . BREAK SEMI_COLON"]
  249 -> 97 [style=solid label="ID"]
  249 -> 1 [style=solid label="INT"]
  249 -> 2 [style=solid label="FLOAT"]
  249 -> 3 [style=solid label="DOUBLE"]
  249 -> 4 [style=solid label="STRING"]
  249 -> 5 [style=solid label="BOOL"]
  249 -> 98 [style=solid label="RETURN"]
  249 -> 99 [style=solid label="WHILE"]
  249 -> 100 [style=solid label="DO"]
  249 -> 101 [style=solid label="IF"]
  249 -> 102 [style=solid label="FOR"]
  249 -> 103 [style=solid label="SWITCH"]
  249 -> 255 [style=solid label="BREAK"]
  249 -> 104 [style=solid label="PRINT"]
  249 -> 105 [style=solid label="SCAN"]
  249 -> 106 [style=solid label="INCREMENT"]
  249 -> 107 [style=solid label="DECREMENT"]
  249 -> 108 [style=dashed label="decl"]
  249 -> 10 [style=dashed label="type"]
  249 -> 147 [style=dashed label="stmt"]
  249 -> 111 [style=dashed label="func_call"]
  249 -> 112 [style=dashed label="return_stmt"]
  249 -> 113 [style=dashed label="assign_stmt"]
  249 -> 114 [style=dashed label="while_stmt"]
  249 -> 115 [style=dashed label="if_stmt"]
  249 -> 116 [style=dashed label="for_stmt"]
  249 -> 117 [style=dashed label="inc_dec"]
  249 -> 118 [style=dashed label="print_stmt"]
  249 -> 119 [style=dashed label="scan_stmt"]
  249 -> 120 [style=dashed label="switch_stmt"]
  250 [label="250\nstmt_list -> stmt_list . stmt\ncase -> CASE FALSE COLON stmt_list . BREAK SEMI_COLON"]
  250 -> 97 [style=solid label="ID"]
  250 -> 1 [style=solid label="INT"]
  250 -> 2 [style=solid label="FLOAT"]
  250 -> 3 [style=solid label="DOUBLE"]
  250 -> 4 [style=solid label="STRING"]
  250 -> 5 [style=solid label="BOOL"]
  250 -> 98 [style=solid label="RETURN"]
  250 -> 99 [style=solid label="WHILE"]
  250 -> 100 [style=solid label="DO"]
  250 -> 101 [style=solid label="IF"]
  250 -> 102 [style=solid label="FOR"]
  250 -> 103 [style=solid label="SWITCH"]
  250 -> 256 [style=solid label="BREAK"]
  250 -> 104 [style=solid label="PRINT"]
  250 -> 105 [style=solid label="SCAN"]
  250 -> 106 [style=solid label="INCREMENT"]
  250 -> 107 [style=solid label="DECREMENT"]
  250 -> 108 [style=dashed label="decl"]
  250 -> 10 [style=dashed label="type"]
  250 -> 147 [style=dashed label="stmt"]
  250 -> 111 [style=dashed label="func_call"]
  250 -> 112 [style=dashed label="return_stmt"]
  250 -> 113 [style=dashed label="assign_stmt"]
  250 -> 114 [style=dashed label="while_stmt"]
  250 -> 115 [style=dashed label="if_stmt"]
  250 -> 116 [style=dashed label="for_stmt"]
  250 -> 117 [style=dashed label="inc_dec"]
  250 -> 118 [style=dashed label="print_stmt"]
  250 -> 119 [style=dashed label="scan_stmt"]
  250 -> 120 [style=dashed label="switch_stmt"]
  251 [label="251\nstmt_list -> stmt_list . stmt\nelse_stmt_opt -> ELSE LBRACE stmt_list . RBRACE"]
  251 -> 97 [style=solid label="ID"]
  251 -> 1 [style=solid label="INT"]
  251 -> 2 [style=solid label="FLOAT"]
  251 -> 3 [style=solid label="DOUBLE"]
  251 -> 4 [style=solid label="STRING"]
  251 -> 5 [style=solid label="BOOL"]
  251 -> 98 [style=solid label="RETURN"]
  251 -> 99 [style=solid label="WHILE"]
  251 -> 100 [style=solid label="DO"]
  251 -> 101 [style=solid label="IF"]
  251 -> 102 [style=solid label="FOR"]
  251 -> 103 [style=solid label="SWITCH"]
  251 -> 104 [style=solid label="PRINT"]
  251 -> 105 [style=solid label="SCAN"]
  251 -> 257 [style=solid label="RBRACE"]
  251 -> 106 [style=solid label="INCREMENT"]
  251 -> 107 [style=solid label="DECREMENT"]
  251 -> 108 [style=dashed label="decl"]
  251 -> 10 [style=dashed label="type"]
  251 -> 147 [style=dashed label="stmt"]
  251 -> 111 [style=dashed label="func_call"]
  251 -> 112 [style=dashed label="return_stmt"]
  251 -> 113 [style=dashed label="assign_stmt"]
  251 -> 114 [style=dashed label="while_stmt"]
  251 -> 115 [style=dashed label="if_stmt"]
  251 -> 116 [style=dashed label="for_stmt"]
  251 -> 117 [style=dashed label="inc_dec"]
  251 -> 118 [style=dashed label="print_stmt"]
  251 -> 119 [style=dashed label="scan_stmt"]
  251 -> 120 [style=dashed label="switch_stmt"]
  252 [label="252\ncase -> CASE STRING_LITERAL COLON stmt_list BREAK . SEMI_COLON"]
  252 -> 258 [style=solid label="SEMI_COLON"]
  253 [label="253\ncase -> CASE INT_NUMBER COLON stmt_list BREAK . SEMI_COLON"]
  253 -> 259 [style=solid label="SEMI_COLON"]
  254 [label="254\ncase -> CASE DOUBLE_NUMBER COLON stmt_list BREAK . SEMI_COLON"]
  254 -> 260 [style=solid label="SEMI_COLON"]
  255 [label="255\ncase -> CASE TRUE COLON stmt_list BREAK . SEMI_COLON"]
  255 -> 261 [style=solid label="SEMI_COLON"]
  256 [label="256\ncase -> CASE FALSE COLON stmt_list BREAK . SEMI_COLON"]
  256 -> 262 [style=solid label="SEMI_COLON"]
  257 [label="257\nelse_stmt_opt -> ELSE LBRACE stmt_list RBRACE ."]
  258 [label="258\ncase -> CASE STRING_LITERAL COLON stmt_list BREAK SEMI_COLON ."]
  259 [label="259\ncase -> CASE INT_NUMBER COLON stmt_list BREAK SEMI_COLON ."]
  260 [label="260\ncase -> CASE DOUBLE_NUMBER COLON stmt_list BREAK SEMI_COLON ."]
  261 [label="261\ncase -> CASE TRUE COLON stmt_list BREAK SEMI_COLON ."]
  262 [label="262\ncase -> CASE FALSE COLON stmt_list BREAK SEMI_COLON ."]
}
